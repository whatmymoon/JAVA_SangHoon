package days11;

// 일반(상속관계가 없는) 객체의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩. 생성
// 2. 생성자 메서드를 호출

// 상속관계 있는 객체(자식객체)의 생성과정
// 1. 멤버변수들을 Heap 메모리에 로딩, 생성 - 부모/자식 클래스의 모든 멤버변수를 한번에 생성
// 2. 자식클래스 객체가 생성되는 것이므로 자식 클래스의 생성자가 먼저 호출됩니다.
// 3. 자식 클래스의 생성자의 첫번째 실행코드가 부모클래스의 생성자를 호출합니다.
//		- 자식 클래스의 생성자 명령중 첫줄이 부모클래스의 생성자 호출이라는 뜻입니다.
// 		- 자식 클래스 생성자 명령 첫줄은 super(); 라는 명령이며, 따로 기술하지 않아도 존재하는 명령입니다.
//  	- 디폴트 생성자 처럼 꺼내서 직접 쓰기전까지는 숨어있는 명령이라고 할 수 있습니다.
// 4. 부모클래스 생성자를 모두 실행한 후 자식클래스 생성자의 남은 명령을 실행합니다.
//  	- 구조가 이렇게 짜여진 이유를 들자면, 부모클래스의 private 멤버를 자식 클래스의 생성자에게 초기화할 수 없으므로
//  	- 부모클래스생성자를 통해 접근하고 초기화하기 위함입니다.

class SuperB{
	int superNum;
	SuperB(){
		System.out.println("부모클래스의 생성자 실행");
	}
}

class SubB extends SuperB{
	int subNum;
	// 생성자를 별도로 꺼내서 정의 하지 않았다면.....
	// SuperB(){ super(); } 이와 같은 생성자와 명령이 숨어 있는것과 같습니다.
	
	// 생성자를 꺼내서 별도로 정의한 경우 super() 명령외에 다른 명령도 쓸 수 있습니다.
	SubB(){
		super(); // super(); 는 첫번째 실행어로 생략도 가능하다. 부모클래스 생성자가 자식 클래스 생성자에서 첫번째 명령으로 호출됩니다.
		// 이는 생략되어도 똑같이 호출됩니다.
		// 자식 클래스에서 부모클래스 생성자 호출은 super(); 라고 명령하며, 반드시 첫번째 실행코드로 씁니다.
		// super(); 코드는 생략 가능합니다.
		System.out.println("자식클래스의 생성자 실행");
	}
}

public class Extends04 {

	public static void main(String[] args) {
		
		SubB c1 = new SubB();
		
	}

}
